#!/usr/bin/perl -w
### before: #!@PERL@
use strict;
use warnings;

### after: use lib qw(@RT_LIB_PATH@);
use lib qw(/opt/rt4/local/lib /opt/rt4/lib);

use RT;
BEGIN { RT::LoadConfig(); RT::Init(); }

use RT::Migrate;
use RT::Migrate::Importer;
use Getopt::Long;
use Pod::Usage qw//;
use Time::HiRes qw//;

my %OPT = (resume => 1);
GetOptions(
    \%OPT,
    "help|?",
    "quiet|q!",
    "list|l!",

    "resume!",
    "clone|C",
    "originalid|i=s",

    "dump=s@",
) or Pod::Usage::pod2usage();

Pod::Usage::pod2usage(-verbose => 1) if $OPT{help};

Pod::Usage::pod2usage() unless @ARGV == 1;
my ($dir) = @ARGV;
$dir =~ s|/$||;
die "No such directory $dir\n" unless -d $dir;
die "$dir doesn't appear to contain serialized data\n"
    unless -f "$dir/001.dat";

my $import;

my $progress;
if (-f "$dir/rt-serialized" and -t STDOUT and not $OPT{quiet}) {
    my $ref = Storable::retrieve("$dir/rt-serialized");
    $progress = RT::Migrate::progress(
        counts => sub { $import->ObjectCount },
        max    => $ref->{counts},
    );
}

if ($OPT{dump}) {
    die "Dumping objects only works in conjunction with --list\n"
        unless $OPT{list};

    $OPT{dump} = [ split /,/, join(',', @{$OPT{dump}}) ];
}

my $statefile = "$dir/partial-import";
$import = RT::Migrate::Importer->new(
    Clone       => $OPT{clone},
    OriginalId  => $OPT{originalid},
    Progress    => $progress,
    Statefile   => $statefile,
    DumpObjects => $OPT{dump},
    Resume      => $OPT{resume},
);

my $log = RT::Migrate::setup_logging( $dir => 'importer.log' );
print "Logging warnings and errors to $log\n" if $log;

my %counts;
if ($OPT{list}) {
    %counts = $import->List( $dir );

    my $org = $import->Organization;
    print "=========== Dump of $org ===========\n\n";
} else {
    unlink $statefile if -f $statefile and not $OPT{resume};
    %counts = $import->Import( $dir );

    my $org = $import->Organization;
    print "========== Import of $org ==========\n\n";
}

print "Total object counts:\n";
for (sort {$counts{$b} <=> $counts{$a}} keys %counts) {
    printf "%8d %s\n", $counts{$_}, $_;
}

my @missing = $import->Missing;
if (@missing) {
    warn "The following UIDs were expected but never observed:\n";
    warn "    $_\n" for @missing;
}

my @invalid = $import->Invalid;
if (@invalid) {
    warn "The following UIDs (serialized => imported) referred to objects missing from the original database:\n";
    for my $info (@invalid) {
        my $uid = delete $info->{uid};
        my $obj = $import->LookupObj($uid);
        warn sprintf "    %s => %s (%s)\n",
                $uid,
                ($obj && $obj->Id ? $obj->UID : '(not imported)'),
                join(", ", map  { "$_ => $info->{$_}" }
                           grep { defined $info->{$_} }
                                sort keys %$info);
    }
}

if ($log and -s $log) {
    print STDERR "\n! Some warnings or errors occurred during import."
                ."\n! Please see $log for details.\n\n";
}

exit @missing;

=head1 NAME

rt-importer - Import a serialized RT database on top of the current one

=head1 SYNOPSIS

    rt-importer path/to/export/directory

This script is used to import the contents of a dump created by
C<rt-serializer>.  It will create all of the objects in the dump in the
current database; this may include users, queues, and tickets.

It is possible to stop the import process with ^C; it can be later
resumed by re-running the importer.

=head2 OPTIONS

=over

=item B<--list>

Print a summary of the data contained in the dump.

=item B<--clone>

Insert all of the data as an exact clone of the original RT instance.
This requires that the database schema be created, but contain no data.

=item B<--originalid> I<cfname>

Places the original ticket organization and ID into a global custom
field with the given name.  If no global ticket custom field with that
name is found in the current database, it will create one.

=item B<--dump> I<class>[,I<class>]

Prints L<Data::Dumper> representations of the objects of type I<class> in the
serialized data.  This is mostly useful for debugging.

Works only in conjunction with C<--list>.

=back

=cut
